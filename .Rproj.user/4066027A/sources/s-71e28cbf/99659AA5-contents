---
title: "GoTChA_pipeline"
output: html_document
---

# Running Gotcha with parallel computing in slurm

This is a tutorial for processing [GoT-ChA](https://www.biorxiv.org/content/10.1101/2022.05.11.491515v1.full.pdf) genotyping libraries. The Gotcha R package required for this tutorial can be downloaded [here](https://github.com/landau-lab/Gotcha) 

## Use of BatchMutationCalling function

### First, we load the Gotcha R library and rslurm:

```{r}
library(Gotcha)
library(rslurm)
```

### Then, we can define the paths and inputs for the pipeline

```{r}
path_to_fastqs = "/gpfs/commons/home/tbotella/GOTCHA/MPN15_16_CMP53/MPN15/gotcha_fastqs"
path_out = "/gpfs/commons/home/tbotella/GOTCHA/MPN15_16_CMP53/MPN15/gotcha_fastqs/outs"

barcodes.file.path = "/gpfs/commons/home/tbotella/GOTCHA/MPN15_16_CMP53/MPN15/MPN15_new_ATAC/outs/singlecell.csv"

which.read = "R3"

read.region = c(34:37)
mutation.start = 34
mutation.end = 37

primer.sequence = "AAAGCCTGTAGTTTTACTTACTCTCGTCTCCACA"

wt.sequence = "GAC" 
mut.sequence= "GAA"

sample_id = "MPN15"
gene_id = "JAK2"
```



### We are now ready to run the pipeline

```{r}
# Split the fastq files in chunks to allow for parallel processing and filter out reads that contain low quality scores,
# particularly at the mutation site of interest
FastqFiltering(
   path = path_to_fastqs,
   out = path_out,
   reads = 250000,
   min.quality = 15,
   min.bases = 1,
   which.read = which.read,
   read.region = read.region,
   ncores = 19
   )
 

if (which.read == "R3") {
	which.read = "R2"
	print('--Changed which.read to "R2"--')
}

# Run Gotcha with parallel computing in slurm: submit one cluster job per fastq chunk
BatchMutationCalling(out  = path_out,
                     barcodes.file.path = barcodes.file.path,
                     wt.max.mismatch = 0, 
                     mut.max.mismatch = 0, 
                     keep.raw.reads = F, 
                     reverse.complement = T, 
                     testing = F,
                     which.read = which.read, 
                     primer.sequence = primer.sequence, 
                     primed.max.mismatch = 3, 
                     wt.sequence = wt.sequence, 
                     mut.sequence = mut.sequence,
                     mutation.start = mutation.start,
                     mutation.end = mutation.end,
                     soptions = list(output=paste0('GoT_','%x_%j.log'),mem = '10g', 'cpus-per-task' = 5) 
)

```

### Once the submitted jobs are completed, we can merge the outputs into one single data frame using the MergeMutationCalling function. 
```{r}
#Merge output from each BatchMutationCalling job. 
#Generate a new folder containing a .Rdata class object that can be directly loaded into R
MergeMutationCalling(out = path_out)
```

### We can then load the output from the MutationCalling function
```{r}
load(paste0(path_out,'Split/Filtered/MergedOuts/outs.collapsed.Rdata'))
outs.collapse$Sample = sample_id
write.csv(outs.collapse,paste0(path_out,'/metadata_',sample_id,'.csv'), row.names = T)
```

### And run the GotchaLabeling function for noise correction and genotype labeling

## Noise Correction and Genotype Labeling
```{r}
#Use wild type and mutant read counts to predict genotype
gotcha_labels <- GotchaLabeling(path=paste0(path_out,'/'), infile = paste0('metadata_',sample_id,'.csv'), gene_id = gene_id, sample_id = sample_id)

saveRDS(gotcha_labels, paste0(path_out,'/gotcha_labels_',sample_id,'.Rds'))
write.csv(as.data.frame(gotcha_labels), paste0(path_out,'/gotcha_labels_',sample_id,'.csv'))
```
```

